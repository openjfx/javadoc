<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>javafx.scene.layout (JavaFX 17)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: module: javafx.graphics, package: javafx.scene.layout">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="about-language">JavaFX&nbsp;17</div>
</div>
<div class="sub-nav">
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<div class="sub-title"><span class="module-label-in-package">Module</span>&nbsp;<a href="../../../module-summary.html">javafx.graphics</a></div>
<h1 title="Package" class="title">Package&nbsp;javafx.scene.layout</h1>
</div>
<section class="package-description" id="package.description">
<div class="block"><p>
Provides classes to support user interface layout.
Each layout pane class supports a different layout strategy for its children
and applications may nest these layout panes to achieve the needed layout structure
in the user interface.  Once a node is added to one of the layout panes,
the pane will automatically manage the layout for the node, so the application
should not position or resize the node directly; see &quot;Node Resizability&quot;
for more details.
</p>

<h2>Scene Graph Layout Mechanism</h2>
<p>
The scene graph layout mechanism is driven automatically by the system once
the application creates and displays a <a href="../Scene.html" title="class in javafx.scene"><code>Scene</code></a>.
The scene graph detects dynamic node changes which affect layout (such as a
change in size or content) and calls <code>requestLayout()</code>, which marks that
branch as needing layout so that on the next pulse, a top-down layout pass is
executed on that branch by invoking <code>layout()</code> on that branch's root.
During that layout pass, the <code>layoutChildren()</code> callback method will
be called on each parent to layout its children.  This mechanism is designed
to maximize layout efficiency by ensuring multiple layout requests are coalesced
and processed in a single pass rather than executing re-layout on on each minute
change. Therefore, applications should not invoke layout directly on nodes.
</p>


<h2>Node Resizability</h2>
<p>
The scene graph supports both resizable and non-resizable node classes.  The
<code>isResizable()</code> method on <a href="../Node.html" title="class in javafx.scene"><code>Node</code></a> returns whether a
given node is resizable or not.  A resizable node class is one which supports a range
of acceptable sizes (minimum &lt;= preferred &lt;= maximum), allowing its parent to resize
it within that range during layout, given the parent's own layout policy and the
layout needs of sibling nodes.  Node supports the following methods for layout code
to determine a node's resizable range:
<pre><code>
    public Orientation getContentBias()
    public double minWidth(double height)
    public double minHeight(double width)
    public double prefWidth(double height)
    public double prefHeight(double width)
    public double maxWidth(double height)
    public double maxHeight(double width)
</code></pre>
<p>
Non-resizable node classes, on the other hand, do <em>not</em> have a consistent
resizing API and so are <em>not</em> resized by their parents during layout.
Applications must establish the size of non-resizable nodes by setting
appropriate properties on each instance. These classes return their current layout bounds for
min, pref, and max, and the <code>resize()</code> method becomes a no-op.</p>
<p>
<br>Resizable classes: <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>, <a href="../../../../javafx.controls/javafx/scene/control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>, <a href="../../../../javafx.web/javafx/scene/web/WebView.html" title="class in javafx.scene.web"><code>WebView</code></a>
<br>Non-Resizable classes: <a href="../Group.html" title="class in javafx.scene"><code>Group</code></a>, <a href="../shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>, <a href="../text/Text.html" title="class in javafx.scene.text"><code>Text</code></a>
</p>
<p>
For example, a Button control (resizable) computes its min, pref, and max sizes
which its parent will use to resize it during layout, so the application only needs
to configure its content and properties:

<pre><code>    Button button = new Button("Apply");
</code></pre>
However, a Circle (non-resizable) cannot be resized by its parent, so the application
needs to set appropriate geometric properties which determine its size:

<pre><code>    Circle circle = new Circle();
    circle.setRadius(50);
</code></pre>

<h2>Resizable Range</h2>

Each resizable node class computes an appropriate min, pref, and max size based
on its own content and property settings (it's 'intrinsic' size range).
Some resizable classes have an unbounded max size (all layout panes) while
others have a max size that is clamped by default to their preferred size (buttons)
(See individual class documentation for the default range of each class).
While these defaults are geared towards common usage, applications often need
to explicitly alter or set a node's resizable range to achieve certain layouts.
The resizable classes provide properties for overriding the min, pref and max
sizes for this purpose.
<p>For example, to override the preferred size of a ListView:</p>
<pre><code>    listview.setPrefSize(200,300);
</code></pre>
<p>Or, to change the max width of a button so it will resize wider to fill a space:
<pre><code>    button.setMaxWidth(Double.MAX_VALUE);
</code></pre>
<p>For the inverse case, where the application needs to clamp the node's min
or max size to its preferred:
<pre><code>    listview.setMaxSize(Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);
</code></pre>
And finally, if the application needs to restore the intrinsically computed values:
<pre><code>    listview.setPrefSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);
</code></pre>

<h2>CSS Styling and Node Sizing</h2>

Applications cannot reliably query the bounds of a resizable node until it has been
added to a scene because the size of that node may be dependent on CSS.  This is
because CSS is used to style many aspects of a node which affect it's preferred size
(font, padding, borders, etc) and so the node cannot be laid out (resized) until
CSS has been applied and the parent can access valid size range metrics.
This is always true for Controls (and any panes that contain them), because they
rely on CSS for their default style, even if no user-level style sheets have been set.
Stylesheets are set at the Scene level, which means that styles cannot even
be determined until a node's enclosing scene has been initialized. Once a Scene
is initialized, CSS is applied to nodes on each pulse (when needed) just before
the layout pass.



<h2>Visual Bounds vs. Layout Bounds</h2>

A graphically rich user interface often has the need to make a distinction between
a node's visual bounds and the bounds used for layout.  For example, the tight visual
bounds of a Text node's character glyphs would not work for layout, as the text
would not be aligned and leading/trailing whitespace would be discounted.  Also,
sometimes applications wish to apply affects and transforms to nodes without
disturbing the surrounding layout (bouncing, jiggling, drop shadows, glows, etc).
To support this distinction in the scene graph, <a href="../Node.html" title="class in javafx.scene"><code>Node</code></a>
provides the <code>layoutBounds</code> property to define the 'logical' bounds
of the node for layout and <code>boundsInParent</code> to define the visual bounds
once all effects, clipping, and transforms have been applied.

<p>These two bounds properties will often differ for a given node and
<code>layoutBounds</code> is computed differently depending on the node class:

<table border="1">
 <caption>Bounds Computation Table</caption>
 <thead>
     <tr>
         <th scope="col">Node Type</th>
         <th scope="col">Layout Bounds</th>
     </tr>
 </thead>
 <tbody>
     <tr>
         <th scope="row"><a href="../shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>,<a href="../image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a></th>
         <td>Includes geometric bounds (geometry plus stroke).
             Does NOT include effect, clip, or any transforms.
         </td>
     </tr>
     <tr>
         <th scope="row"><a href="../text/Text.html" title="class in javafx.scene.text"><code>Text</code></a></th>
         <td>logical bounds based on the font height and content width, including white space.
             can be configured to be tight bounds around chars glyphs by setting <code>boundsType</code>.
             Does NOT include effect, clip, or any transforms.
         </td>
     </tr>
     <tr>
         <th scope="row"><a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>, <a href="../../../../javafx.controls/javafx/scene/control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>, <a href="../../../../javafx.web/javafx/scene/web/WebView.html" title="class in javafx.scene.web"><code>WebView</code></a></th>
         <td>always <code>[0,0 width x height]</code> regardless of visual bounds,
             which might be larger or smaller than layout bounds.
         </td>
     </tr>
     <tr>
         <th scope="row"><a href="../Group.html" title="class in javafx.scene"><code>Group</code></a></th>
         <td>Union of all visible children's visual bounds (<code>boundsInParent</code>)
             Does NOT include effect, clip, or transforms set directly on group,
             however DOES include effect, clip, transforms set on individual children since
             those are included in the child's <code>boundsInParent</code>.
         </td>
     </tr>
 </tbody>
</table>
<p>
So for example, if a <a href="../effect/DropShadow.html" title="class in javafx.scene.effect"><code>DropShadow</code></a> is added to a shape,
that shadow will <em>not</em>  be factored into layout by default.  Or, if a
<a href="../../animation/ScaleTransition.html" title="class in javafx.animation"><code>ScaleTransition</code></a> is used to
pulse the size of a button, that pulse animation will not disturb layout around
that button.  If an application wishes to have the effect, clip, or transform
factored into the layout of a node, it should wrap that node in a Group.
</p></div>
</section>
<section class="summary">
<ul class="summary-list">
<li>
<div class="type-summary">
<table class="summary-table">
<caption><span>Class Summary</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Class</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="AnchorPane.html" title="class in javafx.scene.layout">AnchorPane</a></th>
<td class="col-last">
<div class="block">AnchorPane allows the edges of child nodes to be anchored to an offset from
 the anchor pane's edges.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="Background.html" title="class in javafx.scene.layout">Background</a></th>
<td class="col-last">
<div class="block">The Background of a <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="BackgroundFill.html" title="class in javafx.scene.layout">BackgroundFill</a></th>
<td class="col-last">
<div class="block">The fill and associated properties that direct how to fill the background of a
 <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BackgroundImage.html" title="class in javafx.scene.layout">BackgroundImage</a></th>
<td class="col-last">
<div class="block">Defines properties describing how to render an image as the background to
 some <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="BackgroundPosition.html" title="class in javafx.scene.layout">BackgroundPosition</a></th>
<td class="col-last">
<div class="block">Represents the position of a <a href="BackgroundImage.html" title="class in javafx.scene.layout"><code>BackgroundImage</code></a> within the
 <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>'s drawing area.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BackgroundSize.html" title="class in javafx.scene.layout">BackgroundSize</a></th>
<td class="col-last">
<div class="block">Defines the size of the area that a BackgroundImage should fill relative
 to the Region it is styling.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="Border.html" title="class in javafx.scene.layout">Border</a></th>
<td class="col-last">
<div class="block">The border of a <a href="Region.html" title="class in javafx.scene.layout"><code>Region</code></a>.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BorderImage.html" title="class in javafx.scene.layout">BorderImage</a></th>
<td class="col-last">
<div class="block">Defines properties describing how to render an image as the border of
 some Region.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="BorderPane.html" title="class in javafx.scene.layout">BorderPane</a></th>
<td class="col-last">
<div class="block">BorderPane lays out children in top, left, right, bottom, and center positions.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BorderStroke.html" title="class in javafx.scene.layout">BorderStroke</a></th>
<td class="col-last">
<div class="block">Defines the stroke to use on a <a href="Border.html" title="class in javafx.scene.layout"><code>Border</code></a> for styling a <code>Region</code>.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="BorderStrokeStyle.html" title="class in javafx.scene.layout">BorderStrokeStyle</a></th>
<td class="col-last">
<div class="block">Defines the style of the stroke to use on one side of a BorderStroke.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BorderWidths.html" title="class in javafx.scene.layout">BorderWidths</a></th>
<td class="col-last">
<div class="block">Defines widths for four components (top, right, bottom, and left).</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="ColumnConstraints.html" title="class in javafx.scene.layout">ColumnConstraints</a></th>
<td class="col-last">
<div class="block">Defines optional layout constraints for a column in a <a href="GridPane.html" title="class in javafx.scene.layout"><code>GridPane</code></a>.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="ConstraintsBase.html" title="class in javafx.scene.layout">ConstraintsBase</a></th>
<td class="col-last">
<div class="block">The base class for defining node-specific layout constraints.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="CornerRadii.html" title="class in javafx.scene.layout">CornerRadii</a></th>
<td class="col-last">
<div class="block">Defines the radii of each of the four corners of a BorderStroke.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="FlowPane.html" title="class in javafx.scene.layout">FlowPane</a></th>
<td class="col-last">
<div class="block">FlowPane lays out its children in a flow that wraps at the flowpane's boundary.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="GridPane.html" title="class in javafx.scene.layout">GridPane</a></th>
<td class="col-last">
<div class="block">GridPane lays out its children within a flexible grid of rows and columns.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="HBox.html" title="class in javafx.scene.layout">HBox</a></th>
<td class="col-last">
<div class="block">HBox lays out its children in a single horizontal row.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="Pane.html" title="class in javafx.scene.layout">Pane</a></th>
<td class="col-last">
<div class="block">Base class for layout panes which need to expose the children list as public
 so that users of the subclass can freely add/remove children.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="Region.html" title="class in javafx.scene.layout">Region</a></th>
<td class="col-last">
<div class="block">Region is the base class for all JavaFX Node-based UI Controls, and all layout containers.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="RowConstraints.html" title="class in javafx.scene.layout">RowConstraints</a></th>
<td class="col-last">
<div class="block">Defines optional layout constraints for a row in a <a href="GridPane.html" title="class in javafx.scene.layout"><code>GridPane</code></a>.</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="StackPane.html" title="class in javafx.scene.layout">StackPane</a></th>
<td class="col-last">
<div class="block">StackPane lays out its children in a back-to-front stack.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="TilePane.html" title="class in javafx.scene.layout">TilePane</a></th>
<td class="col-last">
<div class="block">TilePane lays out its children in a grid of uniformly sized "tiles".</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="VBox.html" title="class in javafx.scene.layout">VBox</a></th>
<td class="col-last">
<div class="block">VBox lays out its children in a single vertical column.</div>
</td>
</tr>
</tbody>
</table>
</div>
</li>
<li>
<div class="type-summary">
<table class="summary-table">
<caption><span>Enum Summary</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Enum</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="BackgroundRepeat.html" title="enum in javafx.scene.layout">BackgroundRepeat</a></th>
<td class="col-last">
<div class="block">Enumeration of options for repeating images in backgrounds</div>
</td>
</tr>
<tr class="row-color">
<th class="col-first" scope="row"><a href="BorderRepeat.html" title="enum in javafx.scene.layout">BorderRepeat</a></th>
<td class="col-last">
<div class="block">Enum indicating the repetition rules for border images.</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-first" scope="row"><a href="Priority.html" title="enum in javafx.scene.layout">Priority</a></th>
<td class="col-last">
<div class="block">Enumeration used to determine the grow (or shrink) priority of a given node's
 layout area when its region has more (or less) space available and
 multiple nodes are competing for that space.</div>
</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</section>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="about-language">JavaFX&nbsp;17</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> Copyright &copy; 2008, 2021, Oracle and/or its affiliates. All rights reserved.</small></small></p>
</footer>
</div>
</div>
</body>
</html>
